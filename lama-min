--[[
    LAMA - Location Aware Movement API - 2013 Sangar

    This program is licensed under the MIT license.
    http://opensource.org/licenses/mit-license.php
]]

-- The absolute path to this file. This is used for generating startup logic
-- which initializes the API by loading it into the OS.
local apiPath = "/lama"

-- This is the name of the file in which we store our state, i.e. the position
-- and facing of the turtle, as well as whether it is currently moving or not.
-- We split this up into several files to keep file i/o while moving minimal.
-- You may want to change this if it collides with another program or API.
local stateFile = {
    position  = "/.lama-state",
    waypoints = "/.lama-waypoints",
    move      = "/.lama-move-state",
    path      = "/.lama-path-state",
    wrap      = "/.lama-wrap-state"
}

-- If you meddle with the state files by hand you may want to set this to false
-- to not lose changes. This deletes state files if they fail validation, so
-- that we don't try to re-parse them over and over again.
local deleteInvalidStateFiles = true

-- If this computer uses a multi-startup script (e.g. Forairan's or mine) this
-- determins the 'priority' with which the API is initialized after a reboot.
-- This should be an integer value in the interval [0, 99], where lower values
-- represent a higher priority.
local startupPriority = 10

-- The filename of the file to backup any original startup file to when
-- creating the startup file used to finish any running moves in case the
-- turtle is forced to shut down during the move. This is only used if no
-- multi-startup-script system is found on the computer.
-- You may want to change this if it collides with another program or API.
local startupBackupFile = "/.lama-startup-backup"

-- Whether to use the same coordinate system Minecraft uses internally. This
-- only influences how the API works from the outside; the state file will
-- always use the internal coordinate system, to provide compatibility.
local useMinecraftCoordinates = true

if lama then local env=getfenv()for k,v in pairs(lama)do env[k]=v end;return end;local state,private;version="1.2"side={forward=0,right=1,back=2,left=3,north=0,east=1,south=2,west=3,front=0,["0"]=0,["1"]=1,["2"]=2,["3"]=3,[0]="north",[1]="east",[2]="south",[3]="west"}reason={unknown="unknown",queue_full="queue_full",coroutine="coroutine",fuel="fuel",block="block",turtle="turtle",unbreakable_block="unbreakable_block",entity="entity",invulnerable_entity="invulnerable_entity"}function get()local position=state.position;return private.toMC(position.x,position.y,position.z,position.f)end;function getX()return select(1,get())end;function getY()return select(2,get())end;function getZ()return select(3,get())end;function getPosition()return vector.new(get())end;function getFacing()return select(4,get())end;function set(x,y,z,facing)if state.move or state.path then error("cannot set position while moving")end;assert(private.isInteger(x),"'x' must be an integral number")assert(private.isInteger(y),"'y' must be an integral number")assert(private.isInteger(z),"'z' must be an integral number")assert(private.isFacing(facing),"'facing' must be one of the lama.side constants")x,y,z,facing=private.fromMC(x,y,z,facing)local position=state.position;position.x=x;position.y=y;position.z=z;position.f=facing;private.save("position")return get()end;function forward(tries,aggressive)if state.move then return false,reason.coroutine end;return private.move(private.direction.forward,tries,aggressive)end;function back(tries)if state.move then return false,reason.coroutine end;return private.move(private.direction.back,tries)end;function up(tries,aggressive)if state.move then return false,reason.coroutine end;return private.move(private.direction.up,tries,aggressive)end;function down(tries,aggressive)if state.move then return false,reason.coroutine end;return private.move(private.direction.down,tries,aggressive)end;function moveto(x,y,z,facing,tries,aggressive)return navigate({{x=x,y=y,z=z,facing=facing}},tries,aggressive)end;getfenv()["goto"]=moveto;function navigate(path,tries,aggressive)if state.path then return false,reason.coroutine end;assert(type(path)=="table","'path' must be a table")assert(tries==nil or private.isInteger(tries),"'tries' must be an integral number or omitted")assert(aggressive==nil or type(aggressive)=="boolean","'aggressive' must be a boolean or omitted")local absPath={}for k,v in ipairs(path)do if type(v)=="string"then local x,y,z,f=private.fromMC(waypoint.get(v))table.insert(absPath,{x=x,y=y,z=z,f=f})elseif type(v)=="table"then local x,y,z,f=v.x,v.y,v.z,v.facing;assert(private.isInteger(x),"'x' at index "..k.." must be an integral number")assert(private.isInteger(y),"'y' at index "..k.." must be an integral number")assert(private.isInteger(z),"'z' at index "..k.." must be an integral number")assert(f==nil or private.isFacing(f),"'facing' at index "..k.." must be one of the lama.side constants or omitted")x,y,z,f=private.fromMC(x,y,z,f)table.insert(absPath,{x=x,y=y,z=z,f=f})else error("invalid path entry at index "..k)end end;if#absPath==0 then return true end;for i=1,#absPath-1 do absPath[i].f=nil end;state.path={steps=absPath,tries=tries or 0,aggressive=aggressive or false}private.save("path")return private.navigate()end;function turnRight()local id=turtle.native.turnRight()if id>=0 then state.position.f=(state.position.f+1)%4;private.save("position")return private.waitForResponse(id)end;return false end;function turnLeft()local id=turtle.native.turnLeft()if id>=0 then state.position.f=(state.position.f-1)%4;private.save("position")return private.waitForResponse(id)end;return false end;function turnAround()return turn((getFacing()+2)%4)end;function turn(towards)assert(private.isFacing(towards),"'towards' must be one of the lama.side constants")local ids,position={},state.position;while getFacing()~=towards do local id;if towards==(getFacing()+1)%4 then id=turtle.native.turnRight()if id>=0 then position.f=(position.f+1)%4 else return false end else id=turtle.native.turnLeft()if id>=0 then position.f=(position.f-1)%4 else return false end end;private.save("position")table.insert(ids,id)end;return private.waitForResponse(ids)end;waypoint={}function waypoint.add(name,x,y,z,facing)assert(type(name)=="string"and name~="","'name' must be a non-empty string")assert(x==nil or private.isInteger(x),"'x' must be an integral number or omitted")assert(y==nil or private.isInteger(y),"'y' must be an integral number or omitted")assert(z==nil or private.isInteger(z),"'z' must be an integral number or omitted")assert(facing==nil or private.isFacing(facing),"'facing' must be one of the lama.side constants or omitted")x,y,z,facing=private.fromMC(x,y,z,facing)local position=state.position;if x==nil and y==nil and z==nil and facing==nil then facing=position.f end;x=x or position.x;y=y or position.y;z=z or position.z;local wasOverwritten=waypoint.exists(name)state.waypoints[name]={x=math.floor(x),y=math.floor(y),z=math.floor(z),f=facing}private.save("waypoints")return wasOverwritten end;function waypoint.remove(name)if not waypoint.exists(name)then return false end;state.waypoints[name]=nil;private.save("waypoints")return true end;function waypoint.exists(name)assert(type(name)=="string"and name~="","'name' must be a non-empty string")return state.waypoints[name]~=nil end;function waypoint.get(name)assert(waypoint.exists(name),"no such waypoint, '"..tostring(name).."'")local w=state.waypoints[name]return private.toMC(w.x,w.y,w.z,w.f)end;function waypoint.iter()local name;return function()local coordinate;name,coordinate=next(state.waypoints,name)if name then return name,private.toMC(coordinate.x,coordinate.y,coordinate.z,coordinate.f)end end end;function waypoint.moveto(name,tries,aggressive)x,y,z,facing=waypoint.get(name)return moveto(x,y,z,facing,tries,aggressive)end;waypoint["goto"]=waypoint.moveto;function startupResult()if not private.startupResult then return true end;return private.startupResult.result,private.startupResult.reason end;function hijackTurtleAPI(restore)if restore then if not turtle.__lama then return end;turtle.forward=turtle.__lama.forward;turtle.back=turtle.__lama.back;turtle.up=turtle.__lama.up;turtle.down=turtle.__lama.down;turtle.turnRight=turtle.__lama.turnRight;turtle.turnLeft=turtle.__lama.turnLeft;turtle.__lama=nil else if turtle.__lama then return end;turtle.__lama={forward=turtle.forward,back=turtle.back,up=turtle.up,down=turtle.down,turnRight=turtle.turnRight,turnLeft=turtle.turnLeft}turtle.forward=function()return forward()~=false end;turtle.back=function()return back()~=false end;turtle.up=function()return up()~=false end;turtle.down=function()return down()~=false end;turtle.turnRight=turnRight;turtle.turnLeft=turnLeft end end;if useMinecraftCoordinates then for k,v in pairs(side)do if type(v)=="number"then side[k]=(v+2)%4 end end;side[0],side[1],side[2],side[3]=side[2],side[3],side[0],side[1]end;do local function makeReadonly(table,name)setmetatable(table,{__index=function(t,k)error("Trying to access invalid '"..name.."' constant '"..k.."'.")end,__newindex=function()error("Trying to modify readonly table.")end})end;makeReadonly(side,"lama.side")makeReadonly(reason,"lama.reason")end;private={}private.direction={[1]="forward",[2]="back",[3]="up",[4]="down",forward=1,back=2,up=3,down=4}state={position={x=0,y=0,z=0,f=0},waypoints={},move=nil,path=nil,wrap=0}private.schema={}private.schema[version]={position={type="table",properties={x={type="number",value=private.isInteger},y={type="number",value=private.isInteger},z={type="number",value=private.isInteger},f={type="number",value=private.isFacing}}},waypoints={type="table",entries={type="table",keytype="string",properties={x={type="number",value=private.isInteger},y={type="number",value=private.isInteger},z={type="number",value=private.isInteger},f={type="number",value=private.isFacing,optional=true}}}},move={type="table",optional=true,properties={direction={type="number",value=function(v)return private.direction[v]~=nil end},preMoveFuel={type="number",value=private.isInteger},tries={type="number",value=private.isInteger},aggressive={type="boolean"}}},path={type="table",optional=true,properties={steps={type="table",entries={type="table",properties={x={type="number",value=private.isInteger},y={type="number",value=private.isInteger},z={type="number",value=private.isInteger},f={type="number",value=private.isFacing,optional=true}}}},tries={type="number",value=private.isInteger},aggressive={type="boolean"}}},wrap={type="number",value=private.isInteger}}private.schema["1.0"]={type="table",properties={position={type="table",properties={x={type="number",value=private.isInteger},y={type="number",value=private.isInteger},z={type="number",value=private.isInteger},f={type="number",value=private.isFacing}}},moving={type={"boolean","string"},value=function(v)if type(v)=="string"then return v=="forward"or v=="back"or v=="up"or v=="down"end;return true end},preMoveFuel={type="number",value=private.isInteger},tries={type="number",value=private.isInteger},aggressive={type="boolean"}}}function private.validate(value,schema)assert(schema~=nil,"no schema given")local function validate(value,schema,path)if schema.optional and value==nil then return true end;if type(schema.type)=="table"then local ok=false;for _,valueType in pairs(schema.type)do if type(value)==valueType then ok=true;break end end;if not ok then return false,path..": invalid type; is "..type(value)..", should be one of ["..table.concat(schema.type,", ").."]"end elseif schema.type and type(value)~=schema.type then return false,path..": invalid type; is "..type(value)..", should be "..schema.type end;if schema.value and not schema.value(value)then return false,path..": invalid value"end;if schema.properties then for property,propertySchema in pairs(schema.properties)do local result,location=validate(value[property],propertySchema,path.."."..property)if not result then return result,location end end end;if schema.entries then for key,entry in pairs(value)do if schema.entries.keytype and type(key)~=schema.entries.keytype then return false,path.."["..key.."]: invalid key type; is "..type(key)..", should be "..schema.entries.keytype end;local result,location=validate(entry,schema.entries,path.."["..key.."]")if not result then return result,location end end end;return true end;return validate(value,schema,"value")end;function private.isInteger(value)return type(value)=="number"and value==math.floor(value)end;function private.isFacing(value)return type(value)=="number"and private.isInteger(value)and value>=0 and value<4 end;function private.save(what)local data=textutils.serialize(state[what])local file=fs.open(stateFile[what],"w")file.write(data)file.close()end;function private.load()if private.upgrade()then return end;local function load(section)local filename=stateFile[section]if not fs.exists(filename)then return true end;assert(not fs.isDir(filename),"Invalid state filename '"..filename.."': it's a folder.")local success,result=private.unserialize(filename)if success then local valid,reason=private.validate(result,private.schema[version][section])if valid then state[section]=result;return true else if deleteInvalidStateFiles then print("LAMA: Invalid file '"..filename.."' ("..reason.."), deleting and resetting.")else print("LAMA: Invalid file '"..filename.."' ("..reason.."), resetting.")end end end;return false end;for section,_ in pairs(stateFile)do if not load(section)then private.reset()return end end end;function private.unserialize(filename)local file=fs.open(filename,"r")local data=file.readAll()file.close()return true,textutils.unserialize(data)end;function private.upgrade()if not fs.exists(stateFile.position)or fs.isDir(stateFile.position)then return false end;local success,result=private.unserialize(stateFile.position)if not success or not private.validate(result,private.schema["1.0"])then return false end;print("upgrading state file")state.position=result.position;if type(result.moving)=="string"then state.move={direction=private.direction[result.moving],preMoveFuel=result.preMoveFuel,tries=result.tries,aggressive=result.aggressive}state.wrap=1 end;private.save("position")private.save("move")private.save("wrap")return true end;function private.reset()state.position.x=0;state.position.y=0;state.position.z=0;state.position.f=0;state.waypoints={}state.move=nil;state.path=nil;state.wrap=0;if deleteInvalidStateFiles then fs.delete(stateFile.position)fs.delete(stateFile.move)fs.delete(stateFile.path)fs.delete(stateFile.wrap)end end;local startupHandlers={default={init=function()assert(type(startupBackupFile)=="string"and startupBackupFile~="","The setting 'startupBackupFile' must be a non-empty string.")end,wrap=function()local haveStartup=fs.exists("/startup")if haveStartup then fs.move("/startup",startupBackupFile)end;local f=fs.open("/startup","w")f.writeLine("os.loadAPI('"..apiPath.."')")if haveStartup then f.writeLine("shell.run('/startup')")else end;f.close()end,unwrap=function()fs.delete("/startup")if fs.exists(startupBackupFile)then fs.move(startupBackupFile,"/startup")end end,test=function()return false end},forairan={init=function()local priority=type(startupPriority)=="number"and string.format("%2d")or tostring(startupPriority)local f=fs.open("/init-scripts/"..priority.."_lama","w")f.write("os.loadAPI('"..apiPath.."')")f.close()end,test=function()return fs.exists("/init-scripts")and fs.isDir("/init-scripts")end},sangar={init=function()startup.remove("lama")startup.addString("lama",startupPriority,"os.loadAPI('"..apiPath.."')")end,test=function()return startup~=nil and startup.version~=nil end}}function private.initStartup()assert(private.isInteger(startupPriority),"The setting 'startupPriority' must be an integral number.")private.startupHandler=startupHandlers.default;for _,handler in pairs(startupHandlers)do if handler.test()then private.startupHandler=handler;break end end;if private.startupHandler.init then private.startupHandler.init()end end;function private.wrapStartup()if state.wrap==0 then if private.startupHandler.wrap then private.startupHandler.wrap()end end;state.wrap=state.wrap+1;private.save("wrap")end;function private.unwrapStartup(force)if state.wrap==1 or force and state.wrap>0 then if private.startupHandler.unwrap then private.startupHandler.unwrap()end;state.wrap=0;fs.delete(stateFile.wrap)elseif state.wrap>0 then state.wrap=state.wrap-1;private.save("wrap")end end;function private.toMC(x,y,z,facing)if useMinecraftCoordinates then return y,z,-x,facing and(facing+2)%4 or nil else return x,y,z,facing end end;function private.fromMC(x,y,z,facing)if useMinecraftCoordinates then return-z,x,y,facing and(facing+2)%4 or nil else return x,y,z,facing end end;function private.waitForResponse(ids)if type(ids)~="table"then ids={ids}elseif#ids==0 then return true end;local success=true;repeat local event,responseID,result=os.pullEvent("turtle_response")if event=="turtle_response"then for i=1,#ids do if ids[i]==responseID then success=success and result;table.remove(ids,i)break end end end until#ids==0;return success end;function private.tryGetReason(direction)local detect=({[private.direction.forward]=turtle.detect,[private.direction.up]=turtle.detectUp,[private.direction.down]=turtle.detectDown})[direction]local sideName=({[private.direction.forward]="front",[private.direction.up]="top",[private.direction.down]="bottom"})[direction]if detect then if detect()then if peripheral.isPresent(sideName)and peripheral.getType(sideName)=="turtle"then return reason.turtle else return reason.block end else return reason.entity end end;return reason.unknown end;function private.move(direction,tries,aggressive)assert(tries==nil or type(tries)=="number","'tries' must be a number or omitted")assert(aggressive==nil or type(aggressive)=="boolean","'aggressive' must be a boolean or omitted")if turtle.getFuelLevel()<1 then return false,reason.fuel end;tries=tonumber(tries or 0)aggressive=aggressive and true or false;local move=({[private.direction.forward]=turtle.native.forward,[private.direction.back]=turtle.native.back,[private.direction.up]=turtle.native.up,[private.direction.down]=turtle.native.down})[direction]local detect=({[private.direction.forward]=turtle.detect,[private.direction.up]=turtle.detectUp,[private.direction.down]=turtle.detectDown})[direction]local dig=({[private.direction.forward]=turtle.dig,[private.direction.up]=turtle.digUp,[private.direction.down]=turtle.digDown})[direction]local attack=({[private.direction.forward]=turtle.attack,[private.direction.up]=turtle.attackUp,[private.direction.down]=turtle.attackDown})[direction]local side=({[private.direction.forward]="front",[private.direction.up]="top",[private.direction.down]="bottom"})[direction]local success;repeat local preMoveFuel=turtle.getFuelLevel()local moveId=move()if moveId<0 then private.endMove()return false,reason.queue_full end;state.move={direction=direction,preMoveFuel=preMoveFuel,tries=tries,aggressive=aggressive}private.save("move")private.wrapStartup()success=private.waitForResponse(moveId)private.unwrapStartup()if success then private.updateState()end;if not success then if tries==0 then break end;if detect and detect()then if peripheral.isPresent(side)and peripheral.getType(side)=="turtle"then os.sleep(2)elseif dig and not dig()and tries==1 then private.endMove()return false,reason.unbreakable_block end elseif aggressive and attack and not attack()and tries==1 then private.endMove()return false,reason.invulnerable_entity else os.sleep(1)end;tries=tries-1;os.sleep(0.5)end until success;private.endMove()if success then return true else return false,private.tryGetReason(direction)end end;function private.updateState()local position=state.position;local direction=private.direction[state.move.direction]local delta={forward={1,0,0},right={0,1,0},back={-1,0,0},left={0,-1,0},up={0,0,1},down={0,0,-1}}for i=1,position.f do delta.forward,delta.right,delta.back,delta.left=delta.right,delta.back,delta.left,delta.forward end;position.x=position.x+delta[direction][1]position.y=position.y+delta[direction][2]position.z=position.z+delta[direction][3]private.save("position")end;function private.endMove()state.move=nil;fs.delete(stateFile.move)end;function private.navigate()assert(#state.path.steps>0,"you found a bug")local function travel(axis,distance)if distance==0 then return true end;local directions=({x={side.north,side.south},y={side.east,side.west}})[axis]if directions then local direction=distance>0 and directions[1]or directions[2]turn(direction)end;local action=({x=forward,y=forward,z=distance>0 and up or down})[axis]distance=math.abs(distance)local tries,aggressive=state.path.tries,state.path.aggressive;while distance>0 do local result,reason=action(tries,aggressive)if not result then return result,reason end;distance=distance-1 end;return true end;private.wrapStartup()local result,reason;repeat local x,y,z=private.fromMC(get())local step=state.path.steps[1]local dx,dy,dz=step.x-x,step.y-y,step.z-z;for axis,distance in pairs({x=dx,y=dy,z=dz})do result,reason=travel(axis,distance)if not result then break end end;if result and step.f~=nil then if useMinecraftCoordinates then step.f=(step.f+2)%4 end;result=turn(step.f)if not result then reason=reason.queue_full end end;table.remove(state.path.steps,1)private.save("path")until not result or#state.path.steps==0;private.endNavigate()private.unwrapStartup()return result,reason end;function private.endNavigate()state.path=nil;fs.delete(stateFile.path)end;assert(turtle,"Can only run on turtles.")assert(os.getComputerLabel(),"Turtle has no label, required for state persistence.")assert(turtle.getFuelLevel()~="unlimited","Turtles must use fuel for this API to work correctly.")assert(type(apiPath)=="string"and apiPath~="","The setting 'apiPath' must be a non-empty string.")assert(fs.exists(apiPath)and not fs.isDir(apiPath),"No file found at 'apiPath', please make sure it points to the API.")private.initStartup()private.load()os.sleep(0.1)turtle.detect()private.unwrapStartup(true)if state.move then if turtle.getFuelLevel()==state.move.preMoveFuel then if state.move.tries>0 then local result,reason=private.move(state.move.direction,state.move.tries,state.move.aggressive)private.startupResult={result=result,reason=reason}else private.startupResult={result=false,reason=private.tryGetReason(state.move.direction)}private.endMove()end elseif turtle.getFuelLevel()==state.move.preMoveFuel-1 then private.updateState()private.endMove()else private.reset()error("Unexpected fuel state after reboot; invalid API use?")end end;if state.path then local result,reason=startupResult()if result then private.navigate()else private.endNavigate()end end